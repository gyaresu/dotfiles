{"name":"kal","description":"Simple and useful","keywords":["javascript","language","kal","coffeescript","compiler"],"author":{"name":"Rob Zimmerman"},"version":"0.5.3","licenses":[{"type":"MIT","url":"https://raw.github.com/rzimmerman/kal/master/LICENSE"}],"engines":{"node":">=0.6.0"},"directories":{"lib":"./source/kal"},"main":"./compiled/kal","bin":{"kal":"./scripts/kal"},"scripts":{"make":"mkdir -p compiled && rm -f compiled/* && kal -o compiled/ source/*","bootstrap":"npm run-script make && scripts/kal --minify -o compiled/ source/* && npm test","test":"node_modules/mocha/bin/mocha -r should -R spec tests/* --compilers kal:compiled/kal"},"homepage":"http://rzimmerman.github.io/kal","bugs":{"url":"https://github.com/rzimmerman/kal/issues"},"repository":{"type":"git","url":"git://github.com/rzimmerman/kal.git"},"dependencies":{},"devDependencies":{"mocha":"1.6.x","should":"1.2.x","uglify-js":"2.3.6"},"readme":"# Kal\n\nKal is a highly readable, easy-to-use language that compiles to JavaScript. It's designed to be asynchronous and can run both on [node.js](http://nodejs.org/) and in the browser. Kal makes asynchronous programming easy and clean by allowing functions to [pause and wait for I/O](#asynchronous-wait-for), replacing an awkward callback syntax with a clean, simple syntax.\n\nFor an overview, see [the Github page](http://rzimmerman.github.io/kal/) or check out the [examples](https://github.com/rzimmerman/kal/tree/master/examples).\n\nKal is _expressive_ and offers many useful synonyms and constructs to make code readable in almost plain English.\n\nKal is designed with a unique philosophy:\n\n 1. Eliminate the yucky parts of JavaScript, but keep the good stuff including the compatibility, and the great server and client runtime support.\n 2. Make code as readable as possible and make writing code straightforward. Eliminate the urge (and the need) to be terse and complicated.\n 3. Provide an alternative to callbacks (which look weird) and promises (which are weird) while providing excellent, easy-to-use asynchronous support.\n\nCheck out the [examples](./examples) for some sample use cases.\n\n## Installation Using npm\n\nThis is the preferred method for installing Kal. Make sure you have installed [node.js](http://nodejs.org/). Kal works with versions 0.6, 0.8, and 0.10. It might work with other versions as well. Install the latest \"stable\" release of Kal using npm:\n\n```\nsudo npm install -g kal\n```\n\n`sudo` may not be required depending on how you installed `node`.\n\n## Syntax Highlighting\n\nA [TextMate bundle](https://github.com/rzimmerman/kal.tmbundle) for TextMate and Sublime Text is available with limited but very useful support for Kal's syntax.\n\n[Vim support](https://github.com/bcho/kal-vim) is also available thanks to @bcho.\n\n## Help and Support\n\nVisit the [Google group](https://groups.google.com/forum/#!forum/kal-programming-language) to ask questions and interact.\n\nFile an issue on Github or send a pull request if you have something to add!\n\n## Installing from the Repository\n\n[![Build Status](https://secure.travis-ci.org/rzimmerman/kal.png?branch=master)](https://travis-ci.org/rzimmerman/kal)\n\nIf you need the latest and greatest (possibly unstable/broken) build, you can build Kal manually. Most users can skip this section and just use the latest `npm` version.\n\nKal is written in Kal, so you need a prebuilt version of the compiler available to do the initial build:\n\n```\nsudo npm install -g kal\n```\n\nThen you can clone the repo, install the developer dependencies, and build the compiler:\n\n```\ngit clone https://github.com/rzimmerman/kal kal\ncd kal\nnpm install\nnpm run-script make\n```\n\nRun the tests to make sure everything is going well:\n\n```\nnpm test\n```\n\nIf you're extra serious, you can use your new build to rebuild itself in case there were any notable changes to the compiler between the npm release and the latest commit. This will also run the tests.\n\n```\nnpm run-script bootstrap\n```\n\nNow install your latest version using npm:\n\n```\nnpm pack\n```\n\nAssuming the tests pass, this will make an archive file that you can install (the filename depends on the version):\n\n```\nsudo npm install -g kal-0.x.x.tgz\n```\n\nAlternatively you can just run the `scripts/kal` file if you don't want to install it globally.\n\n## Usage\n\nIf you installed Kal globally (using the `-g` option), you can run the interactive shell by running `kal` with no arguments.\n\n```\n$ kal\nkal> 'hello' + ' ' + 'world'\n'hello world'\n```\n\nYou can use the kal utility to run or compile files. Run `kal -h` for the full option set. If you installed kal locally (didn't use the -g option), you will need to specify the path to the kal executable, usually located at `node_modules/kal/scripts/kal`.\n\n```\nkal path/to/file.kal                                            --runs the specified file\nkal -o path/for/output path/to/file1.kal path/to/file2.kal ...  --compiles all files/directories listed to javascript\n                                                                  and writes the output into the folder specified by -o\n```\n\nUsing the `-j` or `--javascript` switches will show the output of the compiler.\n\nIf you import Kal in your Javascript code, it installs a compile hook that allows you to directly import .kal files:\n\n```javascript\nrequire('kal');\nrequire('./mykalfile'); //refers to mykalfile.kal\n```\n\n## Literate Kal\n\nLiterate Kal offer an exciting way to write well-documented, readable code. The idea is based on [Literate CoffeeScript](http://coffeescript.org/#literate). The compiler will treat any file with a `.litkal` or `.md` extension as a [Markdown](http://daringfireball.net/projects/markdown/) document. Code blocks, denoted by four spaces of indentation, are treated as Kal code while anything that is not indented is treated as a comment. See [this example](https://github.com/rzimmerman/kal/blob/master/examples/literate.litkal) of a Literate Kal file. New in 0.5.2.\n\n## Whitespace and Indentation\n\nIn Kal, spaces for indentation are significant and tabs are not valid. Indents are required for function definitions and blocks of code inside of `if` statements, `try`/`catch` blocks, and loops.\n\nYou should use two spaces to denote an indent. You can technically use any multiple of two spaces, but two is recommended as a style guideline. Any whitespace on blank lines is ignored. Semicolons at the end of statements are not required nor are they valid.\n\nIn general single statements cannot contain line breaks. Notable exceptions are list and object definitions. For example:\n\n```kal\na = [1, 2,\n    3,\n    4]\n\nb = {a:1\n     c:2}\n```\n\nWill work, however:\n\n```kal\na = 1 +\n    1\n```\n\nIs invalid. Future versions may include better support for line breaks within statements.\n\n## Comments\n\nComments are preceeded by a `#` sign. Anything after the `#` on the line will be ignored.\n\n```kal\nprint 5 #this is a comment\n```\n\nMultiline comments are enclosed by `###`:\n\n```kal\n###\nA multiline\ncomment\n###\n```\n\n## Functions and Tasks\n\n**Functions** are defined with an optional name and a list of arguments.\n\n```kal\nfunction my_function(arg1, arg2)\n  return arg1 + arg2\n```\n\nand\n\n```kal\nmy_function = function (arg1, arg2)\n  return arg1 + arg2\n```\n\nBoth define a variable `my_function` that takes two arguments and returns their sum. CoffeeScript syntax is also valid:\n\n```kal\nmy_function = (arg1, arg2) ->\n  return arg1 + arg2\n```\n\nBut is generally discouraged unless it significantly helps readability. It was originally included to ease porting of the Kal compiler from CoffeeScript to Kal. Coffee-style functions must contain a line break after the `->`. `=>` is not supported.\n\nFunctions can have default arguments. These will be used if the specified argument is `null` or `undefined`:\n```kal\nfunction default_args(x,y=2)\n  return x + y\n\nprint default_args(1) # prints 3\n```\n\nFunctions are called using parentheses.\n\n```kal\nmy_function(1, 2)\n```\n\nWill return `3`. Parentheses are optional if the function has at least one argument:\n\n```kal\nmy_function 1, 2\n```\n\nIs also valid. Function calls can be chained this way as well, so any of the following\n\n```kal\nprint(my_function(1,2))\nprint my_function 1, 2\nprint my_function(1, 2)\n```\n\nwill all print `3`. When calling a function with no arguments, parentheses are required.\n\n**Tasks** are similar to functions, except that they are intended to be called asynchronously (usually using a `wait for` statement).\n\n```kal\ntask my_task(arg)\n  return arg * 2\n```\n\nor\n\n```kal\nmy_task = task (arg)\n  return arg * 2\n```\n\nTasks should not be called synchronously. If a task is called synchronously, it will return with no value. When called asynchronously.\n\n```kal\nprint my_task 1\n```\n\nIs valid syntax, but will print `undefined`.\n\n```kal\nwait for x from my_task(1)\nprint x\n```\n\nWill print `2` as expected. See the `wait for` section for more details on asynchronous calls.\n\n## Objects and Arrays\n\nObjects and arrays are defined similarly to JavaScript. Newlines **are** valid inside of an array or object definition and indentation is ignored. Commas are optional when followed by a newline. CoffeeScript-style object definitions (no `{}`s) are only valid in assignments and must be preceded by a newline.\n\n```kal\na = [1, 2, 3]\nb = [1\n     2,\n     3\n     4]\nc = {a:1,b:2,c:{d:3}}\nd =\n  a:1, b:2\n  c:\n    d:3\n```\n\nFunction definitions are only valid in CoffeeScript-style object definitions at this time.\n\n```kal\nd =\n  a:1, b:2\n  c:\n    d: function ()\n      return 2\n    e: ->\n      return 3\n```\n\nObjects work like JavaScript objects (because they are JavaScript objects), so you can access members either using array subscripts or `.` notation\n\n```kal\nx =\n  a : 1\n  b : 2\nprint x['a'] #prints 1\nprint x.b    #prints 2\n```\n\n## Scoping\n\nVariables are declared automatically and scoped within the current function unless used globally (like CoffeeScript).\n\nBy default, nothing in your `.kal` file will leak to the global scope. Everything is wrapped within a function scope inside the module. If you need to export variables to global scope, you should use\n\n```kal\nmodule.exports.my_export = my_variable_or_function # in node.js\nwindow.my_export = my_variable_or_function         # in a browser\n```\n\n_or_ you can compile the file with the `--bare` option.\n\n## Conditionals\n\nThe following defines a conditional statement:\n\n```kal\nx = 5\nif x is 5\n  print 'five'\n```\n\nwill print `five`.\n\n```kal\nx = 6\nif x is 5\n  print 'five'\nelse\n  print 'not five'\n```\n\nwill print `not five`\n\nThe conditional has useful synonyms:\n\n* `when` is equivalent to `if`\n* `unless` is equivalent to `if not`\n* `except when` is equivalent to `if not`\n* `otherwise` is equivalent to `else`\n\nSo the following is valid, as are other permutations:\n\n```kal\nunless name is 'Steve'\n  print 'Impostor!'\notherwise\n  print 'Steve'\n```\n\n`else` (and synonyms) can be chained with `if` (and synonyms), so\n\n```kal\nif name is 'Steve'\n  print 'Steve'\nelse if name is 'Brian'\n  print 'Brian'\notherwise when name is 'Joe'\n  print 'Joe'\nelse\n  print 'Somebody'\n```\n\nis valid.\n\nConditionals can also tail a statement:\n\n```kal\nprint 5 if 5 > 10\n```\n\nwill do nothing.\n\nConditionals can be used in a ternary statement as well\n\n```kal\nprint(5 if name is 'Joe' otherwise 6)\n```\n\nwill print `5` if the variable name is equal to `'Joe'`, otherwise it will print `6`. Kind of like it says. Parentheses are required because tail conditionals associate right, meaning the following are equivalent:\n\n```kal\nprint 5 if name is 'Joe' otherwise 6\n(print(5) if name is 'Joe') otherwise 6\n```\n\n## Loops\n\n`for` loops work as follows:\n\n```kal\nfor x in [1,2,3]\n  print x\n```\n\nWill print the numbers 1, 2, and 3. The value n the right of the `for ... in` expression is called the `iterant`. Currently it must be an array. Python-like iterable object support is coming soon.\n\n`for` loops can also be used on objects:\n\n```kal\nobj = {a:1,b:2}\nfor key of obj\n  print key, obj[key]\n```\n\nWill print `a 1` and `b 2`.\n\nWhen used on asynchronous code, the `parallel` and `series` specifiers are available:\n\n```kal\nfor parallel x in y\n  wait for z from f(x)\n\nfor series x in y\n  wait for z from f(x)\n```\n\n`series` is the default if neither is specified. Parallel for loops are **not** guaranteed to execute in order! In fact, they often won't. Take special care when accessing variables separated by `wait for` asynchronous statements. Remember that a `wait for` releases control of execution, so other loop iterations running in parallel may alter local variables if you are not careful. See the `wait for` section for more details.\n\n`while` loops continuously run their code block until a condition is satisfied.\n\n```kal\nx = 0\nwhile x < 5\n  x += 1\n  print x\n```\n\nprints the numbers 1 through 5. `until` provides a similar function.\n\n```kal\nx = 0\nuntil x is 5\n  x += 1\n  print x\n```\n\n## Comprehensions\n\nList comprehensions are a quick and useful way to create an array from another array:\n\n```kal\ny = [1,2,3]\nx = [value * 2 for value in y]\n```\n\nwill set `x` equal to `[2,4,6]`. Comprehensions also support an iterable object. Iterable objects support a `next()` method which returns the next value in the sequence each time it is called. When there are no more values in the sequence, it should return `null`.\n\n```kal\nclass RandomList:\n  method initialize(size)\n    me.counter = size\n  method next()\n    me.counter -= 1\n    if me.counter >= 0\n      return Math.random()\n    else\n      return null\n\nx = [r * 10 for r in new RandomList(20)]\n```\n\nwill set `x` to an array of 20 random numbers between 0 and 10.\n\nList comprehensions work on objects, too:\n\n```kal\nobj = {a:1, b:2}\nx = [p for property p in obj]               # ['a','b']\nx = [v for property value v in obj]         # [1, 2]\nx = [p+v for propert p with value v in obj] # ['a1', 'b2']\n```\n\nConditionals in list comprehensions are coming soon.\n\n## Operators And Constants\n\nListed below are Kal's operators and their other-language equivalents. Note that Kal has a lot of synonyms for some keywords, all of which compile to the same function.\n\n| Kal                        | CoffeeScript            | JavaScript                | Function                       |\n|:--------------------------:|:-----------------------:|:-------------------------:|--------------------------------|\n| `true`, `yes`, `on`        | `true`, `yes`, `on`     | `true`                    | Boolean true                   |\n| `false`, `no`, `off`       | `false`, `no`, `off`    | `false`                   | Boolean false                  |\n| `and`, `but`               | `and`                   | `&&`                      | Boolean and                    |\n| `or`                       | `or`                    | <code>&#124;&#124;</code> | Boolean or                     |\n| `nor`                      | none                    | none                      | Boolean or, inverted           |\n| `not`                      | `not`, `!`              | `!`                       | Boolean not                    |\n| `xor`, `bitwise xor`       | `^`                     | `^`                       | Bitwise xor                    |\n| `bitwise not`              | `~`                     | `~`                       | Bitwise not (invert)           |\n| `bitwise and`              | `&`                     | `&`                       | Bitwise and                    |\n| `bitwise or`               | <code>&#124;</code>     | <code>&#124;</code>       | Bitwise or                     |\n| `bitwise left`             | `<<`                    | `<<`                      | Bitwise shift left             |\n| `bitwise right`            | `>>`                    | `>>`                      | Bitwise shift right            |\n| `+`, `-`, `*`, `/`, `mod`  | `+`, `-`, `*`, `/`, `%` | `+`, `-`, `*`, `/`, `%`   | Math operators                 |\n| `^`                        | none                    | none                      | Exponent (`Math.pow`)          |\n| `exists`, `?`              | `?`                     | none                      | Existential check              |\n| `doesnt exist`             | none                    | none                      | Existential check (inverted)   |\n| `is`, `==`                 | `is`, `==`              | `===`                     | Boolean equality               |\n| `isnt`, `!=`               | `isnt`, `==`            | `!==`                     | Boolean inequality             |\n| `>`, `>=`, `<`, `<=`       | `>`, `>=`, `<`, `<=`    | `>`, `>=`, `<`, `<=`      | Boolean comparisons            |\n| `me`, `this`               | `@`, `this`             | `this`                    | Current object                 |\n| `in`, `not in`             | `in`, `not in`          | none                      | Boolean search of array/string |\n| `of`                       | `of`                    | `in`                      | Boolean search of object       |\n| `nothing`, `empty`, `null` | `null`                  | `null`                    | Null value                     |\n| `undefined`                | `undefined`             | `undefined`               | no value                       |\n| `instanceof`               | `instanceof`            | `instanceof`              | inheritance check              |\n| `print`                    | `console.log`           | `console.log`             | alias for `console.log`        |\n\n## Exisential Checks\n\nKal implements the same existential operator features of CoffeeScript, with the addition of the `exists` and `doesnt exist` keyword suffixes, which perform the same function as the `?` operator. Examples:\n\n```kal\na = {a:1}\nb = [1,2,3]\n\nprint(c exists) # false\nprint(c doesnt exist) #true\nprint(c?) #false\n\nprint(c.something) #throws an error!\nprint(c?.something) #prints undefined\n\nprint(a?.a) # 1\nprint(a?.a?) # true\nprint(b?[2]) # 3\n\nprint c() # error!\nprint c?() # prints undefined\n```\n\n## Classes and Inheritence\n\nClasses are defined with member `method` definitions. Methods are just functions that are added to the prototype of new instance objects (in other words, they are available to all instances of a class). The `initialize` method, if present, is used as the constructor when the `new` keyword is used. `me` (or its synonym `this`) is used in methods to access the current instance of the class. `instanceof` checks if an object is an instance of a class.\n\n```kal\nclass Person\n  method initialize(name)\n    me.name = name\n  method printName()\n    print me.name\n  method nameLength()\n    return me.name.length\n\njen = new Person('Jen')\njen.printName() # prints 'Jen'\nprint(jen instanceof Person) # prints true\n```\n\nClasses can inherit from other classes and override or add to their method definitions. The `super` keyword can be used in a method to call the same function in the parent class.\n\n```kal\nclass FrumpyPerson inherits from Person\n  method printName()\n    print 'Frumpy ' + me.name\n  method nameLength()\n    return 0\n\nsue = new FrumpyPerson('Sue')\nsue.printName() # prints 'Frumpy Sue'\nprint(sue instanceof Person) # prints true\nprint(sue instanceof FrumpyPerson) # prints true\nprint(jen instanceof FrumpyPerson) # prints false\n```\n\nYou can add or alter a method or task to a class after it is defined (or from another file) using late binding using the `of` keyword.\n\n```kal\nclass MyClass\n  method my_method(v)\n    me.v = v\n\nx = new MyClass()\nx.my_method(10)\nprint x.v # prints 10\n\nmethod my_method(v) of MyClass\n  me.v = v + 1\n\nmethod my_other_method() of MyClass\n  print me.v\n\nx = new MyClass()\nx.my_method 10\nx.my_other_method() # prints 11\n```\n\n## Try/Catch\n\n`try` and `catch` blocks work similarly to JavaScript/CoffeeScript. `finally` blocks are not supported yet but are coming eventually. The `throw` statement (and its synonyms `raise` and `fail with`) work like JavaScript as well.\n\n```kal\ntry\n  a = 'horse' / 2 # what are we doing? this will throw an error!\n  b = 1 # never runs\ncatch e\n  print 'caught it!', e\n```\n\nThe `e` variable above stores the error object thrown with `throw` or by the system. You can give it any name you want and it is optional. The following is valid:\n\n```kal\ntry\n  throw 'a string'\n  b = 1 # never runs\ncatch\n  print 'caught it!'\n```\n\n`try`/`catch` blocks can be nested. `try` blocks can contain asynchronous `wait for` calls, but `catch` blocks cannot at this time.\n\n## Strings\n\nStrings can either be double-quoted (`\"`) or single quoted (`'`). Backslashes can be used to escape quotes within strings if necessary.\n\n```kal\nx = 'this is a \"string\" with quotes in it'\ny = \"so is 'this'\"\nz = 'this one is, \\'too\\' but I\\'m not proud of it'\n```\n\n## String Interpolation\n\nDouble-quoted strings can contain interpolated values using `#{...}` blocks. These blocks can contain any valid Kal expression (including variables and function calls). This is the recommended way to do string concatenation as it is usually more readable.\n\n```kal\nprint \"This is a string with the number 3: #{1+1+1}\"\n\"This is a string with the number 3: 3\"\n\na = cow\nn = moo\nprint \"The #{a} says #{n}, #{n}, #{n}!\"\n\"The cow says, moo, moo, moo!\"\n```\n\n## Regular Expressions\n\nKal supports JavaScript's regex syntax, but not CoffeeScript style block regex syntax.\n\n## Asynchronous Wait For\n\nThe `wait for` statement executes a `task` and pauses execution (yielding to the runtime) until the `task` is complete. The following reads a file asynchronously and prints its contents (in node.js).\n\n```kal\nfs = require 'fs'\nwait for data from fs.readFile '/home/user/file.txt'\nprint data.toString()\n```\n\nNote that:\n\n* For users familiar with node.js and JavaScript, `fs.readFile` is called with the file name argument and a callback. **You don't need to supply a callback.**\n* After the `wait for` line, execution is paused and other code can run. Keep this in mind if you have global variables that are modified asynchronously as they may change between the `wait for` line and the line after it.\n* Any errors reported by `fs.readFile` (returned via callback) **will be thrown automatically**. You should wrap the `wait for` in a `try`/`catch` if you want to catch these errors.\n\n`wait for` can be used to call your own asynchronous tasks. It can also be used within `for` and `while` loops, `try` blocks, `if` statements, and **any nesting combination** you can think of. Really!\n\n```kal\nfs = require 'fs'\ntask readFileSafe(filename)\n  if 'secret' in filename\n    throw 'Illegal Access!'\n  else\n    wait for d from fs.readFile filename\n    return d\n\nfor parallel filename in ['secret/data.txt', 'test.txt', 'test2.txt']\n  try\n    wait for data from readFileSafe '/home/secret/file.txt'\n    print data.toString()\n  catch error\n    print \"ERROR: #{error}\"\nprint 'DONE!'\n```\n\n`wait for` can also be used without arguments by omitting the `from` keyword\n\n```kal\nwait for my_task()\n```\n\nSome node.js API functions (like `http.get`) don't follow the normal convention of calling back with an error argument. For these functions you must use the `safe` prefix, otherwise it will throw an error:\n\n```kal\nhttp = require 'http'\nsafe wait for request from http.get 'http://www.google.com'\nprint request.responseCode\n```\n\n`wait for` statements also support multiple return values\n\n```kal\nwait for a, b from my_task()\n```\n\n## Asynchronous Pause\n\nYou can pause for a specified amount of time using the `pause for` keyword\n\n```kal\nprint 'starting'\npause for 1 second\nprint 'done!'\n```\n\n`pause for` uses JavaScript's `setTimeout` function. Note that the argument is in seconds, not milliseconds like `setTimeout`.\n\nThe `second` keyword is optional. `seconds` also works. Use your best judgement to keep your code readable.\n\n```kal\npause for 2          # seconds is implied\npause for 10 seconds # also valid\nmilliseconds = 1293\npause for milliseconds/1000 seconds # expressions are valid for the timeout\n```\n\n## Parallel Tasks\n\nYou can kick off tasks in parallel with the `run in parallel` block\n\n```kal\nrun in parallel\n  task1()\n  wait for task2 a, b, c\n  wait for x from task3()\n  safe wait for y, z from task4()\nprint 'all tasks finished'\n```\n\nCode after the `run in parallel` block will not run until all tasks have completed. If any errors are thrown by one or more tasks, an array of errors will be thrown after all tasks in the block complete (or fail). Array elements are in the order that the tasks were specified. If no error was thrown by a task, its error element will be `undefined` (`doesnt exist` will be true). `safe` waits will not check for errors.\n\n```kal\ntry\n  run in parallel\n    task_that_fails()\n    task_that_succeeds()\ncatch errors\n  print errors[0] # prints the error thrown by task_that_fails\n  print errors[1] exists # prints false\n```\n","readmeFilename":"README.md","_id":"kal@0.5.3","dist":{"shasum":"153b26bc7084a5a777b0ac97dd12adba714f3956","tarball":"http://registry.npmjs.org/kal/-/kal-0.5.3.tgz"},"_from":".","_npmVersion":"1.3.8","_npmUser":{"name":"rzimmerman","email":"rmzimmerman@gmail.com"},"maintainers":[{"name":"rzimmerman","email":"rmzimmerman@gmail.com"}],"_etag":"\"3GE297CHOSUPOQP9ZNB8EFKTI\""}